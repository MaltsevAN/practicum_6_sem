N - число вершин
M - число ребер
Время DiGraph(const int n) = время resize = O(N)
Время add = { если петля - то не добавляем, для алгоритма == вершина,
              в ином случае (время [] в std::vector + push_back(т.к выделили заранее просто O(1)))
              = O(1)} - для M ребер = O(M)
Время void dfs1(node_type v) = O(N+M) - сложность топологической сортировки
Время  void dfs2(node_type v) = O(N+M)
Итоговое время O(N+M)

Память graph_type = O(N+M) - два граффа прямой и транспонированный
        vector_nodes = O(N)
        component = O(N)
        res = O(N)
        void dfs1(node_type v) = O(N)
        void dfs2(node_type v) = O(N)
        scc() - O(N)
Итого: O(N+M)

Преймущества:
    1) Не добавляем петли - выигрыш по памяти, при большом количестве петель.
    2) Использование транспонированного графа - получаем выигрыш по времени, проигрыш по памяти,
        преймещество объясняется тем, что на каждом шаге из "корневой" вершины не выходят ребра в другие компоненты,
        за счет того, что scc(G^T) = scc(G)^T, т.е. dfs2 - обходит вершины одной компоненты
    3) убраны незначительные переменные из лекционного алгоритма
    4) при повторном вызове алгоритма для немодифицированного графа время работы O(1)

Чтение данных происзодит с файла, примером которого служит input.txt
в первой строке количество вершин
в последующих ребра в формате v1 v2








